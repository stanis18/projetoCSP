--------------------------------Constants--------------------------------
datatype Status = FUNDED | RELEASED
datatype TransactionType = ETHER | TOKEN

datatype address = zeroAddress | zeroX.{uint256} -- ???Como representar melhor strings???
datatype bytes32 = b32.{uint256}
datatype bytes20 = b20.{uint256}

datatype numbersType = uint | uint8 | uint32 | uint256 

Transaction = {(value, lastModified, status, transactionType, threshold, timeoutHours, 
buyer, seller, tokenAddress, moderator, released, noOfReleases) | 
value <- {uint256}, lastModified <- {uint256}, status <- Status, 
transactionType <- TransactionType, threshold <- {uint8}, timeoutHours <- {uint32},
buyer <- address, seller <- address, tokenAddress <- address, moderator <- address,
released <- {uint256}, noOfReleases <- {uint256}} 

ParametersAddTransaction = {(buyer, seller, moderator, threshold, timeoutHours, scriptHash, value,
uniqueId, transactionType, tokenAddress) | 
buyer <- address, seller <- address, moderator <- address, threshold <- {uint8},
timeoutHours <- {uint32}, scriptHash <- bytes32, value <- {uint256}, uniqueId <- bytes20,
transactionType <- TransactionType, tokenAddress <- address} 

ParametersCalculateRedeemScriptHash = {(buyer, seller, moderator, threshold, timeoutHours, uniqueId, tokenAddress) | 
buyer <- address, seller <- address, moderator <- address, threshold <- {uint8},
timeoutHours <- {uint32}, uniqueId <- bytes20, tokenAddress <- address} 

ParametersAddTokensToTransaction = {(scriptHash, value) | value <- {uint256}, scriptHash <- bytes32 } 

--------------------------------Channels--------------------------------
channel syncAddTransaction : bytes32.Transaction
channel syncAddTokeToTransacion : bytes32.{uint256}
channel syncgetTransaction

--------------------------------OpenBazaar--------------------------------



--------------------------------Contract--------------------------------
channel addTokenTransaction, checkBeneficiary, checkVote
channel addFundsToTransaction, getAllTransactionsForParty
channel execute, getTransactionHash

channel createTransaction : Transaction
channel addTransaction : ParametersAddTransaction
channel calculateRedeemScriptHash : ParametersCalculateRedeemScriptHash.bytes32
channel addTokensToTransaction : ParametersAddTokensToTransaction

channel errorUser

Escrow =   addTransaction?parameters -> addTransaction_(parameters)
        [] addTokenTransaction -> Escrow
        [] checkBeneficiary -> Escrow 
        [] checkVote -> Escrow
        [] addFundsToTransaction -> Escrow
        [] addTokensToTransaction?parameters -> addTokensToTransaction_(parameters) 
        [] getAllTransactionsForParty -> Escrow
        [] execute -> Escrow
        [] getTransactionHash -> Escrow
        [] calculateRedeemScriptHash?parameters!getBytes(calculateRedeemScriptHash_(parameters)) -> Escrow


--Método adicionar Transações--


addTransaction_(parameters) =  if getBuyer(parameters) !=  getSeller(parameters) then 
                                  if getValue(parameters) > 0 then 
                                    if getThreshold(parameters) > 0 then 
                                        if getThreshold(parameters) <= 3 then 
                                            if (getThreshold(parameters)  == 1 or getModerator(parameters) != zeroAddress ) then 
                                                if(getScriptHash(parameters) == getBytes(calculateRedeemScriptHash_((getBuyer(parameters), getSeller(parameters), getModerator(parameters), getThreshold(parameters), getTimeoutHours(parameters), getUniqueId(parameters), getTokenAddress(parameters))))) then 
                                                    createTransaction?transaction ->  syncAddTransaction!getScriptHash(parameters)!transaction -> Escrow
                                                else throwError('f')
                                            else throwError('e') --??? Como representar melhor os erros ???
                                        else throwError('d')
                                    else throwError('c')
                                  else  throwError('b')
                               else throwError('a')

throwError(mesage) = errorUser -> Escrow


-- para retornar valores dos parametros
getValue((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = 3 -- ???Como representar os numeros sem travar???
getThreshold((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = 2
getBuyer((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = buyer
getSeller((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = seller
getTransactionType((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = transactionType
getScriptHash((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = scriptHash
getModerator((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = moderator
getUniqueId((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = uniqueId
getTokenAddress((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = tokenAddress
getTimeoutHours((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = timeoutHours


-- Metodo para calcular o scriptHash
calculateRedeemScriptHash_((buyer, seller, moderator, threshold, timeoutHours, uniqueId, tokenAddress)) = bytes32
getBytes({bytes}) = bytes

--Metodo addTokenTransaction

addTokensToTransaction_((scriptHash, value)) = syncAddTokeToTransacion!scriptHash!value -> Escrow

--Windows
WEscrow = {|addTransaction, addTokenTransaction, checkBeneficiary, checkVote, 
addFundsToTransaction, addTokensToTransaction, getAllTransactionsForParty, 
execute, getTransactionHash, calculateRedeemScriptHash,
createTransaction, syncAddTransaction, errorUser, syncAddTokeToTransacion,
syncgetTransaction|}


--------------------------------Blockchain--------------------------------
InitBlockchain = Blockchain((| |), (| |))

Blockchain(transactions, partyVsTransaction) =  syncAddTransaction?keyBytes32?transaction -> Blockchain(updateBlockchainAddTransaction((keyBytes32, transaction), transactions), partyVsTransaction)
                                            []  syncAddTokeToTransacion?scriptHash?value -> Blockchain(transactions, partyVsTransaction)
                                            []  syncgetTransaction -> Blockchain(transactions, partyVsTransaction) --Retornar a transacao

WBlockchain = {|syncAddTransaction, syncAddTokeToTransacion, syncgetTransaction|}


updateBlockchainAddTransaction(value, map) = mapFromList(mapToList(map) ^ <value>) --Converte o mapa para lista adiciona o valor e após isso para mapa novamente

lookForTransaction(map, key) = mapLookup(map, key) -- ???Como tratar esses erros???

--------------------------------Utils--------------------------------
--SafeMath
add(x, y) = numbersType


--------------------------------Asserts & Paralelism--------------------------------

EscrowAndBlockchain = Escrow [ WEscrow || WBlockchain ] InitBlockchain

assert InitBlockchain :[deadlock free]
assert InitBlockchain :[deterministic]

assert Escrow :[deadlock free]
assert Escrow :[deterministic]


assert EscrowAndBlockchain :[deadlock free]
assert EscrowAndBlockchain :[deterministic]

