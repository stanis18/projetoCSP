--------------------------------Constants--------------------------------
datatype Status = FUNDED | RELEASED
datatype TransactionType = ETHER | TOKEN

datatype address = zeroAddress | zeroX.{uint256} -- ???Como representar melhor strings???
datatype bytes32 = b32.{uint256}
datatype bytes20 = b20.{uint256}
datatype list = arrayUint256 | arrayAddress

datatype numbersType = uint | uint8 | uint32 | uint256 

datatype expection = expection1  | expection2  | expection3  | expection4  | expection5  |
                     expection6  | expection7  | expection8  | expection9  | expection10 |
                     expection11 | expection12 | expection13 | expection14 | expection15

Transaction = {(value, lastModified, status, transactionType, threshold, timeoutHours, 
buyer, seller, tokenAddress, moderator, released, noOfReleases) | 
value <- {uint256}, lastModified <- {uint256}, status <- Status, 
transactionType <- TransactionType, threshold <- {uint8}, timeoutHours <- {uint32},
buyer <- address, seller <- address, tokenAddress <- address, moderator <- address,
released <- {uint256}, noOfReleases <- {uint256}} 

ParametersAddTransaction = {(buyer, seller, moderator, threshold, timeoutHours, scriptHash, value,
uniqueId, transactionType, tokenAddress) | 
buyer <- address, seller <- address, moderator <- address, threshold <- {uint8},
timeoutHours <- {uint32}, scriptHash <- bytes32, value <- {uint256}, uniqueId <- bytes20,
transactionType <- {ETHER}, tokenAddress <- address} 

ParametersAddTransactionToken = {(buyer, seller, moderator, threshold, timeoutHours, scriptHash, value,
uniqueId, transactionType, tokenAddress) | 
buyer <- address, seller <- address, moderator <- address, threshold <- {uint8},
timeoutHours <- {uint32}, scriptHash <- bytes32, value <- {uint256}, uniqueId <- bytes20,
transactionType <- {TOKEN}, tokenAddress <- address} 

ParametersCalculateRedeemScriptHash = {(buyer, seller, moderator, threshold, timeoutHours, uniqueId, tokenAddress) | 
buyer <- address, seller <- address, moderator <- address, threshold <- {uint8},
timeoutHours <- {uint32}, uniqueId <- bytes20, tokenAddress <- address} 
                                                                --??? Value é do tipo uint ???
ParametersAddTokensToTransaction = {(scriptHash, value, msgSender) | value <- {0..2}, scriptHash <- bytes32, msgSender <- address } 

ParametersGetTransactionHash = {(scriptHash, destinations, amounts) | scriptHash <- bytes32, destinations <- { arrayAddress }, amounts <- { arrayUint256 }} 

--------------------------------Channels--------------------------------
channel syncAddTransaction : bytes32.Transaction
channel syncAddFundsOrTokensToTransaction : bytes32.Transaction

channel syncGetTransactionID : bytes32
channel syncGetTransaction : Transaction


--------------------------------Contract--------------------------------
channel checkBeneficiary, checkVote
channel getAllTransactionsForParty
channel execute

channel createTransaction : Transaction
channel addTransaction : ParametersAddTransaction
channel addTokenTransaction : ParametersAddTransactionToken
channel calculateRedeemScriptHash : ParametersCalculateRedeemScriptHash.bytes32
channel addTokensToTransaction, addFundsToTransaction : ParametersAddTokensToTransaction
channel getTransactionHash : ParametersGetTransactionHash.bytes32

channel returnError : expection

Escrow =   addTransaction?parameters -> addTransaction_(parameters)
        [] addTokenTransaction?parameters -> addTransaction_(parameters)
        [] checkBeneficiary -> checkBeneficiary_()
        [] checkVote -> checkVote_()
        [] addFundsToTransaction?parameters -> addFundsToTransaction_(parameters)
        [] addTokensToTransaction?parameters -> addTokensToTransaction_(parameters) 
        [] getAllTransactionsForParty -> getAllTransactionsForParty_()
        [] execute -> execute_()
        [] getTransactionHash?parameters!getBytes(getTransactionHash_(parameters)) -> Escrow
        [] calculateRedeemScriptHash?parameters!getBytes(calculateRedeemScriptHash_(parameters)) -> Escrow


--Método adicionar Transações--

addTransaction_(parameters) =  if getBuyer(parameters) !=  getSeller(parameters) then 
                                  if getValue(parameters) > 0 then 
                                    if getThreshold(parameters) > 0 then 
                                        if getThreshold(parameters) <= 3 then 
                                            if (getThreshold(parameters)  == 1 or getModerator(parameters) != zeroAddress ) then 
                                                if(getScriptHash(parameters) == getBytes(calculateRedeemScriptHash_((getBuyer(parameters), getSeller(parameters), getModerator(parameters), getThreshold(parameters), getTimeoutHours(parameters), getUniqueId(parameters), getTokenAddress(parameters))))) then 
                                                    createTransaction?transaction -> syncAddTransaction!getScriptHash(parameters)!transaction -> Escrow
                                                else throwError(expection6)
                                            else throwError(expection5) 
                                        else throwError(expection4)
                                    else throwError(expection3)
                                  else  throwError(expection2)
                               else throwError(expection1)

throwError(err) = returnError!err -> Escrow


-- para retornar valores dos parametros addTransaction_
getValue((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = 3 -- ???Como representar os numeros sem travar???
getThreshold((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = 2
getBuyer((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = buyer
getSeller((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = seller
getTransactionType((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = transactionType
getScriptHash((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = scriptHash
getModerator((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = moderator
getUniqueId((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = uniqueId
getTokenAddress((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = tokenAddress
getTimeoutHours((buyer, seller, moderator, threshold, timeoutHours, scriptHash, value, uniqueId, transactionType, tokenAddress)) = timeoutHours

-- retornar valores de uma transação
getBuyerTransaction((value, lastModified, status, transactionType, threshold, timeoutHours, buyer, seller, tokenAddress, moderator, released, noOfReleases)) = buyer 
getStateTransaction((value, lastModified, status, transactionType, threshold, timeoutHours, buyer, seller, tokenAddress, moderator, released, noOfReleases)) = status 
getTypeTransaction((value, lastModified, status, transactionType, threshold,  timeoutHours, buyer, seller, tokenAddress, moderator, released, noOfReleases)) = transactionType 


-- Metodo para calcular o scriptHash
calculateRedeemScriptHash_((buyer, seller, moderator, threshold, timeoutHours, uniqueId, tokenAddress)) = bytes32


--Metodo addTokenTransaction
channel createNewITokenContract, teste
channel fundAddedEvent :  {0..2}.bytes32.address
addTokensToTransaction_((scriptHash, value, msgSender)) = syncGetTransactionID!scriptHash -> ( syncGetTransaction?transaction -> (if getStateTransaction(transaction) == FUNDED then 
                                                                                                                                if getTypeTransaction(transaction) == TOKEN then 
                                                                                                                                    if getBuyerTransaction(transaction) == msgSender then 
                                                                                                                                        if value > 0 then
                                                                                                                                             syncAddFundsOrTokensToTransaction!scriptHash!transaction -> fundAddedEvent!value!scriptHash!msgSender -> Escrow
                                                                                                                                        else throwError(expection11)
                                                                                                                                    else throwError(expection10)
                                                                                                                                else throwError(expection9)
                                                                                                                            else throwError(expection8))
                                                                                             [] transactionDoesNotExists -> throwError(expection7) )


                                                                                                                            

addFundsToTransaction_((scriptHash, value, msgSender)) = syncGetTransactionID!scriptHash -> ( syncGetTransaction?transaction -> (if getStateTransaction(transaction) == FUNDED then 
                                                                                                                                if getTypeTransaction(transaction) == ETHER then 
                                                                                                                                    if getBuyerTransaction(transaction) == msgSender then 
                                                                                                                                        if value > 0 then
                                                                                                                                            createNewITokenContract -> syncAddFundsOrTokensToTransaction!scriptHash!transaction -> fundAddedEvent!value!scriptHash!msgSender -> Escrow
                                                                                                                                        else throwError(expection11)
                                                                                                                                    else throwError(expection10)
                                                                                                                                else throwError(expection9)
                                                                                                                            else throwError(expection8))
                                                                                             [] transactionDoesNotExists -> throwError(expection7) )








--Metodo para conseguir o hash da transacao
getTransactionHash_((scriptHash, destinations, amounts)) = bytes32


checkBeneficiary_() = Escrow

checkVote_() = Escrow



getAllTransactionsForParty_() = Escrow


execute_() = Escrow

--Windows
WEscrow = {|addTransaction, addTokenTransaction, checkBeneficiary, checkVote, 
addFundsToTransaction, addTokensToTransaction, getAllTransactionsForParty, 
execute, getTransactionHash, calculateRedeemScriptHash, syncAddFundsOrTokensToTransaction,
createTransaction, syncAddTransaction, returnError, 
syncGetTransaction, syncGetTransactionID, transactionDoesNotExists, createNewITokenContract,
fundAddedEvent|}


--------------------------------Blockchain--------------------------------
channel transactionDoesNotExists

InitBlockchain = Blockchain((| |), (| |))

Blockchain(transactions, partyVsTransaction) =  syncAddTransaction?scriptHash?transaction -> Blockchain(transactions, partyVsTransaction)  --??? Atualizar o map com a nova transacao(esta havendo um deadlock)???            
                                            []  syncGetTransactionID?scriptHash -> if mapMember(transactions, scriptHash) then syncGetTransaction!lookForTransaction(transactions, scriptHash) -> syncAddFundsOrTokensToTransaction?scriptHash?transaction -> Blockchain(updateBlockchainUpdateTransaction(scriptHash, transaction, transactions), partyVsTransaction)   --Retornar a transacao
                                                                                   else transactionDoesNotExists -> Blockchain(transactions, partyVsTransaction)  
                                                                          
                                                  

WBlockchain = {|syncAddTransaction, syncAddFundsOrTokensToTransaction, syncGetTransaction, syncGetTransactionID, 
transactionDoesNotExists|}


updateBlockchainAddTransaction(value, map) = mapFromList(mapToList(map) ^ <value>) --Converte o mapa para lista adiciona o valor e após isso para mapa novamente

updateBlockchainUpdateTransaction(scriptHash, transaction, map) = mapUpdate(map, scriptHash, transaction)

lookForTransaction(map, key) = mapLookup(map, key) 

--------------------------------Utils--------------------------------
--SafeMath ???? Adicionar o valor a transção ???
add((value, lastModified, status, transactionType, threshold, timeoutHours, buyer, seller, tokenAddress, moderator, released, noOfReleases), valueToAdd) = (value, lastModified, status, transactionType, threshold, timeoutHours, buyer, seller, tokenAddress, moderator, released, noOfReleases)

getBytes({bytes}) = bytes
--------------------------------Asserts & Paralelism--------------------------------

EscrowAndBlockchain = Escrow [ WEscrow || WBlockchain ] InitBlockchain

assert InitBlockchain :[deadlock free]
assert InitBlockchain :[deterministic]

assert Escrow :[deadlock free]
assert Escrow :[deterministic]


assert EscrowAndBlockchain :[deadlock free]
assert EscrowAndBlockchain :[deterministic]

--------------------------------Apêndice--------------------------------

-- expection1 -> "Buyer and seller are same"
-- expection2 -> "Value passed is 0"
-- expection3 -> "Threshold must be greater than 0"
-- expection4 -> "Threshold must not be greater than 3"
-- expection5 -> "Either threshold should be 1 or valid moderator address should be passed"
-- expection6 -> "Calculated script hash does not match passed script hash."
-- expection7 -> "Transaction does not exist"
-- expection8 -> Transaction is not in FUNDED state
-- expection9 -> Transaction type does not match
-- expection10 -> "The initiator of the transaction is not buyer"
-- exception11 -> "Value must be greater than zero."